
build/main.o:     file format elf32-i386
build/main.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000374  00000000  00000000  00000040  2**4
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003b4  2**0
                  ALLOC
  3 .rodata       0000000c  00000000  00000000  000003b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000305  00000000  00000000  000003c0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  5 .debug_abbrev 00000167  00000000  00000000  000006c5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_aranges 00000020  00000000  00000000  0000082c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  7 .debug_line   00000155  00000000  00000000  0000084c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  8 .debug_str    00000215  00000000  00000000  000009a1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_line_str 0000004e  00000000  00000000  00000bb6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000013  00000000  00000000  00000c04  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000f4  00000000  00000000  00000c18  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 main.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .rodata	00000000 .rodata
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 g     F .text	00000143 digit_to_number
00000000         *UND*	00000000 malloc
00000150 g     F .text	00000025 put_pixel
00000180 g     F .text	00000066 draw_square
000001f0 g     F .text	000000d3 draw_square_exce
000002d0 g     F .text	000000a4 main
00000000         *UND*	00000000 get_OS_FUNCTIONS_addr
00000000         *UND*	00000000 enable_int
00000000         *UND*	00000000 finish_int
00000000         *UND*	00000000 print
00000000         *UND*	00000000 sleep_this
00000000         *UND*	00000000 new_line
00000000         *UND*	00000000 sleep
00000000         *UND*	00000000 set_buffer



Disassembly of section .text:

00000000 <digit_to_number>:
extern void get_screen_accessASM();
extern void test_screen_bufferASM();
extern void testesCRL();

char *digit_to_number()
{
   0:	83 ec 1c             	sub    $0x1c,%esp
    int res = 123;
   3:	c7 44 24 0c 7b 00 00 	movl   $0x7b,0xc(%esp)
   a:	00 
    char *t;

    int count = 3;
   b:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  12:	00 

    t = malloc(count);
  13:	8b 44 24 08          	mov    0x8(%esp),%eax
  17:	83 ec 0c             	sub    $0xc,%esp
  1a:	50                   	push   %eax
  1b:	e8 fc ff ff ff       	call   1c <digit_to_number+0x1c>
			1c: R_386_PC32	malloc
  20:	83 c4 10             	add    $0x10,%esp
  23:	89 44 24 04          	mov    %eax,0x4(%esp)
    res = res / 10;
  27:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  2b:	ba 67 66 66 66       	mov    $0x66666667,%edx
  30:	89 c8                	mov    %ecx,%eax
  32:	f7 ea                	imul   %edx
  34:	89 d0                	mov    %edx,%eax
  36:	c1 f8 02             	sar    $0x2,%eax
  39:	c1 f9 1f             	sar    $0x1f,%ecx
  3c:	89 ca                	mov    %ecx,%edx
  3e:	29 d0                	sub    %edx,%eax
  40:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res * 10;
  44:	8b 54 24 0c          	mov    0xc(%esp),%edx
  48:	89 d0                	mov    %edx,%eax
  4a:	c1 e0 02             	shl    $0x2,%eax
  4d:	01 d0                	add    %edx,%eax
  4f:	01 c0                	add    %eax,%eax
  51:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res / 10;
  55:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  59:	ba 67 66 66 66       	mov    $0x66666667,%edx
  5e:	89 c8                	mov    %ecx,%eax
  60:	f7 ea                	imul   %edx
  62:	89 d0                	mov    %edx,%eax
  64:	c1 f8 02             	sar    $0x2,%eax
  67:	c1 f9 1f             	sar    $0x1f,%ecx
  6a:	89 ca                	mov    %ecx,%edx
  6c:	29 d0                	sub    %edx,%eax
  6e:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res / 10;
  72:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  76:	ba 67 66 66 66       	mov    $0x66666667,%edx
  7b:	89 c8                	mov    %ecx,%eax
  7d:	f7 ea                	imul   %edx
  7f:	89 d0                	mov    %edx,%eax
  81:	c1 f8 02             	sar    $0x2,%eax
  84:	c1 f9 1f             	sar    $0x1f,%ecx
  87:	89 ca                	mov    %ecx,%edx
  89:	29 d0                	sub    %edx,%eax
  8b:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res * 10;
  8f:	8b 54 24 0c          	mov    0xc(%esp),%edx
  93:	89 d0                	mov    %edx,%eax
  95:	c1 e0 02             	shl    $0x2,%eax
  98:	01 d0                	add    %edx,%eax
  9a:	01 c0                	add    %eax,%eax
  9c:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res / 10;
  a0:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  a4:	ba 67 66 66 66       	mov    $0x66666667,%edx
  a9:	89 c8                	mov    %ecx,%eax
  ab:	f7 ea                	imul   %edx
  ad:	89 d0                	mov    %edx,%eax
  af:	c1 f8 02             	sar    $0x2,%eax
  b2:	c1 f9 1f             	sar    $0x1f,%ecx
  b5:	89 ca                	mov    %ecx,%edx
  b7:	29 d0                	sub    %edx,%eax
  b9:	89 44 24 0c          	mov    %eax,0xc(%esp)

    res = res * 10;
  bd:	8b 54 24 0c          	mov    0xc(%esp),%edx
  c1:	89 d0                	mov    %edx,%eax
  c3:	c1 e0 02             	shl    $0x2,%eax
  c6:	01 d0                	add    %edx,%eax
  c8:	01 c0                	add    %eax,%eax
  ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res / 10;
  ce:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  d2:	ba 67 66 66 66       	mov    $0x66666667,%edx
  d7:	89 c8                	mov    %ecx,%eax
  d9:	f7 ea                	imul   %edx
  db:	89 d0                	mov    %edx,%eax
  dd:	c1 f8 02             	sar    $0x2,%eax
  e0:	c1 f9 1f             	sar    $0x1f,%ecx
  e3:	89 ca                	mov    %ecx,%edx
  e5:	29 d0                	sub    %edx,%eax
  e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res * 10;
  eb:	8b 54 24 0c          	mov    0xc(%esp),%edx
  ef:	89 d0                	mov    %edx,%eax
  f1:	c1 e0 02             	shl    $0x2,%eax
  f4:	01 d0                	add    %edx,%eax
  f6:	01 c0                	add    %eax,%eax
  f8:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res * 10;
  fc:	8b 54 24 0c          	mov    0xc(%esp),%edx
 100:	89 d0                	mov    %edx,%eax
 102:	c1 e0 02             	shl    $0x2,%eax
 105:	01 d0                	add    %edx,%eax
 107:	01 c0                	add    %eax,%eax
 109:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res / 10;
 10d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 111:	ba 67 66 66 66       	mov    $0x66666667,%edx
 116:	89 c8                	mov    %ecx,%eax
 118:	f7 ea                	imul   %edx
 11a:	89 d0                	mov    %edx,%eax
 11c:	c1 f8 02             	sar    $0x2,%eax
 11f:	c1 f9 1f             	sar    $0x1f,%ecx
 122:	89 ca                	mov    %ecx,%edx
 124:	29 d0                	sub    %edx,%eax
 126:	89 44 24 0c          	mov    %eax,0xc(%esp)
    res = res * 10;
 12a:	8b 54 24 0c          	mov    0xc(%esp),%edx
 12e:	89 d0                	mov    %edx,%eax
 130:	c1 e0 02             	shl    $0x2,%eax
 133:	01 d0                	add    %edx,%eax
 135:	01 c0                	add    %eax,%eax
 137:	89 44 24 0c          	mov    %eax,0xc(%esp)
    return t;
 13b:	8b 44 24 04          	mov    0x4(%esp),%eax
}
 13f:	83 c4 1c             	add    $0x1c,%esp
 142:	c3                   	ret    
 143:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 14a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00000150 <put_pixel>:

void put_pixel(int x, int y, int color, unsigned int *buf)
{
    buf[y * 800 + x] = color;
 150:	8b 44 24 08          	mov    0x8(%esp),%eax
 154:	69 d0 20 03 00 00    	imul   $0x320,%eax,%edx
 15a:	8b 44 24 04          	mov    0x4(%esp),%eax
 15e:	01 d0                	add    %edx,%eax
 160:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 167:	8b 44 24 10          	mov    0x10(%esp),%eax
 16b:	01 c2                	add    %eax,%edx
 16d:	8b 44 24 0c          	mov    0xc(%esp),%eax
 171:	89 02                	mov    %eax,(%edx)
}
 173:	90                   	nop
 174:	c3                   	ret    
 175:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 17c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000180 <draw_square>:

void draw_square(unsigned int x, unsigned int y, unsigned int width, unsigned int height, unsigned int *buf, unsigned int color)
{
 180:	53                   	push   %ebx
 181:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < height; i++)
 184:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 18b:	00 
 18c:	eb 47                	jmp    1d5 <draw_square+0x55>
    {
        for (int j = 0; j < width; j++)
 18e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 195:	00 
 196:	eb 2e                	jmp    1c6 <draw_square+0x46>
        {
            put_pixel(x + j, y + i, color, buf);
 198:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 19c:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 1a0:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 1a4:	01 ca                	add    %ecx,%edx
 1a6:	89 d3                	mov    %edx,%ebx
 1a8:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 1ac:	8b 54 24 18          	mov    0x18(%esp),%edx
 1b0:	01 ca                	add    %ecx,%edx
 1b2:	ff 74 24 28          	pushl  0x28(%esp)
 1b6:	50                   	push   %eax
 1b7:	53                   	push   %ebx
 1b8:	52                   	push   %edx
 1b9:	e8 fc ff ff ff       	call   1ba <draw_square+0x3a>
			1ba: R_386_PC32	put_pixel
 1be:	83 c4 10             	add    $0x10,%esp
        for (int j = 0; j < width; j++)
 1c1:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
 1c6:	8b 44 24 08          	mov    0x8(%esp),%eax
 1ca:	3b 44 24 20          	cmp    0x20(%esp),%eax
 1ce:	72 c8                	jb     198 <draw_square+0x18>
    for (int i = 0; i < height; i++)
 1d0:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
 1d5:	8b 44 24 0c          	mov    0xc(%esp),%eax
 1d9:	3b 44 24 24          	cmp    0x24(%esp),%eax
 1dd:	72 af                	jb     18e <draw_square+0xe>
        }
    }
}
 1df:	90                   	nop
 1e0:	90                   	nop
 1e1:	83 c4 10             	add    $0x10,%esp
 1e4:	5b                   	pop    %ebx
 1e5:	c3                   	ret    
 1e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 1ed:	8d 76 00             	lea    0x0(%esi),%esi

000001f0 <draw_square_exce>:

void draw_square_exce(unsigned int x, unsigned int y, unsigned int width, unsigned int height, unsigned int *buf, unsigned int color)
{
 1f0:	53                   	push   %ebx
 1f1:	83 ec 10             	sub    $0x10,%esp
    for (int j = 0; j < width; j++)
 1f4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 1fb:	00 
 1fc:	eb 4f                	jmp    24d <draw_square_exce+0x5d>
    {
        put_pixel(x + j, y, color, buf);
 1fe:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 202:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 206:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 20a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 20e:	01 d9                	add    %ebx,%ecx
 210:	ff 74 24 28          	pushl  0x28(%esp)
 214:	52                   	push   %edx
 215:	50                   	push   %eax
 216:	51                   	push   %ecx
 217:	e8 fc ff ff ff       	call   218 <draw_square_exce+0x28>
			218: R_386_PC32	put_pixel
 21c:	83 c4 10             	add    $0x10,%esp
        put_pixel(x + j, y + height, color, buf);
 21f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 223:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 227:	8b 54 24 24          	mov    0x24(%esp),%edx
 22b:	01 ca                	add    %ecx,%edx
 22d:	89 d3                	mov    %edx,%ebx
 22f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 233:	8b 54 24 18          	mov    0x18(%esp),%edx
 237:	01 ca                	add    %ecx,%edx
 239:	ff 74 24 28          	pushl  0x28(%esp)
 23d:	50                   	push   %eax
 23e:	53                   	push   %ebx
 23f:	52                   	push   %edx
 240:	e8 fc ff ff ff       	call   241 <draw_square_exce+0x51>
			241: R_386_PC32	put_pixel
 245:	83 c4 10             	add    $0x10,%esp
    for (int j = 0; j < width; j++)
 248:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
 24d:	8b 44 24 0c          	mov    0xc(%esp),%eax
 251:	3b 44 24 20          	cmp    0x20(%esp),%eax
 255:	72 a7                	jb     1fe <draw_square_exce+0xe>
    }
    for (int j = 0; j < height; j++)
 257:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 25e:	00 
 25f:	eb 51                	jmp    2b2 <draw_square_exce+0xc2>
    {
        put_pixel(x, y + j, color, buf);
 261:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 265:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 269:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 26d:	01 c8                	add    %ecx,%eax
 26f:	89 c1                	mov    %eax,%ecx
 271:	8b 44 24 18          	mov    0x18(%esp),%eax
 275:	ff 74 24 28          	pushl  0x28(%esp)
 279:	52                   	push   %edx
 27a:	51                   	push   %ecx
 27b:	50                   	push   %eax
 27c:	e8 fc ff ff ff       	call   27d <draw_square_exce+0x8d>
			27d: R_386_PC32	put_pixel
 281:	83 c4 10             	add    $0x10,%esp
        put_pixel(x + width, y + j, color, buf);
 284:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 288:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 28c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 290:	01 ca                	add    %ecx,%edx
 292:	89 d3                	mov    %edx,%ebx
 294:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 298:	8b 54 24 20          	mov    0x20(%esp),%edx
 29c:	01 ca                	add    %ecx,%edx
 29e:	ff 74 24 28          	pushl  0x28(%esp)
 2a2:	50                   	push   %eax
 2a3:	53                   	push   %ebx
 2a4:	52                   	push   %edx
 2a5:	e8 fc ff ff ff       	call   2a6 <draw_square_exce+0xb6>
			2a6: R_386_PC32	put_pixel
 2aa:	83 c4 10             	add    $0x10,%esp
    for (int j = 0; j < height; j++)
 2ad:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
 2b2:	8b 44 24 08          	mov    0x8(%esp),%eax
 2b6:	3b 44 24 24          	cmp    0x24(%esp),%eax
 2ba:	72 a5                	jb     261 <draw_square_exce+0x71>
    }
}
 2bc:	90                   	nop
 2bd:	90                   	nop
 2be:	83 c4 10             	add    $0x10,%esp
 2c1:	5b                   	pop    %ebx
 2c2:	c3                   	ret    
 2c3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000002d0 <main>:

int main()
{
 2d0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 2d4:	83 e4 f0             	and    $0xfffffff0,%esp
 2d7:	ff 71 fc             	pushl  -0x4(%ecx)
 2da:	55                   	push   %ebp
 2db:	89 e5                	mov    %esp,%ebp
 2dd:	51                   	push   %ecx
 2de:	83 ec 14             	sub    $0x14,%esp
    get_OS_FUNCTIONS_addr();
 2e1:	e8 fc ff ff ff       	call   2e2 <main+0x12>
			2e2: R_386_PC32	get_OS_FUNCTIONS_addr

    enable_int();
 2e6:	e8 fc ff ff ff       	call   2e7 <main+0x17>
			2e7: R_386_PC32	enable_int
    finish_int();
 2eb:	e8 fc ff ff ff       	call   2ec <main+0x1c>
			2ec: R_386_PC32	finish_int

    char *runn = "RUNNING...2";
 2f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			2f3: R_386_32	.rodata

    for (int i = 0; i < 10; i++)
 2f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 2fe:	eb 22                	jmp    322 <main+0x52>
    {
        print(runn);
 300:	83 ec 0c             	sub    $0xc,%esp
 303:	ff 75 f0             	pushl  -0x10(%ebp)
 306:	e8 fc ff ff ff       	call   307 <main+0x37>
			307: R_386_PC32	print
 30b:	83 c4 10             	add    $0x10,%esp
        sleep_this(5000);
 30e:	83 ec 0c             	sub    $0xc,%esp
 311:	68 88 13 00 00       	push   $0x1388
 316:	e8 fc ff ff ff       	call   317 <main+0x47>
			317: R_386_PC32	sleep_this
 31b:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < 10; i++)
 31e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 322:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
 326:	7e d8                	jle    300 <main+0x30>
    }

    new_line();
 328:	e8 fc ff ff ff       	call   329 <main+0x59>
			329: R_386_PC32	new_line
    // if (test_ro_data() == 0)
    // {
    //     // dot_rodata_crash();
    //     return 0;
    // }
    print(digit_to_number());
 32d:	e8 fc ff ff ff       	call   32e <main+0x5e>
			32e: R_386_PC32	digit_to_number
 332:	83 ec 0c             	sub    $0xc,%esp
 335:	50                   	push   %eax
 336:	e8 fc ff ff ff       	call   337 <main+0x67>
			337: R_386_PC32	print
 33b:	83 c4 10             	add    $0x10,%esp
    sleep(5000);
 33e:	83 ec 0c             	sub    $0xc,%esp
 341:	68 88 13 00 00       	push   $0x1388
 346:	e8 fc ff ff ff       	call   347 <main+0x77>
			347: R_386_PC32	sleep
 34b:	83 c4 10             	add    $0x10,%esp

    unsigned int *buf = set_buffer();
 34e:	e8 fc ff ff ff       	call   34f <main+0x7f>
			34f: R_386_PC32	set_buffer
 353:	89 45 ec             	mov    %eax,-0x14(%ebp)
    draw_square_exce(0, 0, 20, 20, buf, 0xff0000);
 356:	83 ec 08             	sub    $0x8,%esp
 359:	68 00 00 ff 00       	push   $0xff0000
 35e:	ff 75 ec             	pushl  -0x14(%ebp)
 361:	6a 14                	push   $0x14
 363:	6a 14                	push   $0x14
 365:	6a 00                	push   $0x0
 367:	6a 00                	push   $0x0
 369:	e8 fc ff ff ff       	call   36a <main+0x9a>
			36a: R_386_PC32	draw_square_exce
 36e:	83 c4 20             	add    $0x20,%esp

    while (1)
 371:	90                   	nop
 372:	eb fd                	jmp    371 <main+0xa1>
